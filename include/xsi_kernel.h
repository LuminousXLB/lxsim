#pragma once

#include <filesystem>
#include <memory>
#include <stdexcept>
#include <string>

#include "xsi.h"

#define dprintf(fmt, ...)                                                      \
    fprintf(stderr, "[%s:%d] " fmt, __FILE__, __LINE__, __VA_ARGS__)

namespace XSI {

class PortNotFoundException : public std::exception {
  public:
    PortNotFoundException(const char *port_name) {
        _msg = "Port not found from name: ";
        _msg += port_name;
    }

    PortNotFoundException(int port_number) {
        _msg = "Port not found from number: ";
        _msg += std::to_string(port_number);
    }

    virtual ~PortNotFoundException() throw() {}

    virtual const char *what() const throw() { return _msg.c_str(); }

  private:
    std::string _msg;
};

enum PortDirection {
    INPUT = xsiInputPort,
    OUTPUT = xsiOutputPort,
    INOUT = xsiInoutPort,
};

const char *port_direction_to_string(PortDirection dir);

enum Status {
    NORMAL = xsiNormal,
    ERROR = xsiError,
    FATAL_ERROR = xsiFatalError,
};

class Kernel : public std::enable_shared_from_this<Kernel> {
  protected:
    void *_xsimk;
    xsiHandle _dut;
    s_xsi_setup_info _setup_info;

  public:
    static std::shared_ptr<Kernel> create(const char *xsimk,
                                          bool auto_correct_cwd = false) {
        return std::shared_ptr<Kernel>(new Kernel(xsimk, auto_correct_cwd));
    }

    std::shared_ptr<Kernel> get_shared_ptr() { return shared_from_this(); }

    ~Kernel();

  private:
    Kernel(const char *xsimk, bool auto_correct_cwd);

  public:
    void set_log_filename(const char *filename);
    const char *get_log_filename() const;
    void set_wdb_filename(const char *filename);
    const char *get_wdb_filename() const;

    /**
     * @brief Load the design and initialize the design handle
     *
     * This function is generated by XSim compiler xelab per design
     */
    void open();
    bool is_open() const;

    /**
     * @brief Close simulation and free up memory used by the design
     *
     */
    void close();

    /**
     * @brief Get port number of the specified port name (only top level ports
     * supported)
     *
     * @param port_name is name of the port
     * @return the port number of the specified port
     */
    int get_port_number(const char *port_name) noexcept(false);

    /**
     * @brief Get port name back from port number (only top level ports
     * supported)
     *
     * @param port_number is number returned earlier from call of
     * xsi_get_port_number
     * @return the port name of the specified port if the named port exists
     */
    const char *get_port_name(int port_number);

    /**
     * @brief Put value on the port specified by the port_number
     *
     * @param port_number is position number of the port in HDL port declaration
     * @param value is value buffer of the specified port in XSim value format
     */
    void put_value(int port_number, const s_xsi_vlog_logicval *value);

    /**
     * @brief Read value of the port specified by the port_number
     *
     * @param port_number is position number of the port in HDL port declaration
     * @param value is value buffer of the specified port in XSim value format
     */
    void get_value(int port_number, s_xsi_vlog_logicval *value);

    /**
     * @brief Run simulation for given number of time units
     *
     * @param step is number of units of kernel time precision
     */
    void run(XSI_INT64 step);

    /**
     * @brief Reset simulation time to 0
     */
    void restart();

    /**
     * @brief Gets number of ports in the top module (first top in case of
     * multiple top designs)
     *
     * @return int
     */
    int get_num_ports() const;

    /* The time precision of simulation used by the XSim simulation kernel */
    /* Valid time precision values are from 0 to -15 and they represent
     * following: 0 : 1 s, -1 : 100 ms, -2 : 10 ms, -3 : 1 ms,  -4: 100 us,  -5:
     * 10 us,  -6: 1 us -7 : 100 ns, -8 : 10 ns, -9 : 1 ns, -10: 100 ps, -11: 10
     * ps, -12: 1 ps -13: 100 fs, -14: 10 fs, -15: 1 fs
     */

    /**
     * @brief The time precision of simulation used by the XSim simulation
     * kernel
     *
     * Valid time precision values are from 0 to -15 and they represent
     * following:
     *  0 : 1 s,
     * -1 : 100 ms, -2 : 10 ms, -3 : 1 ms,  -4: 100 us,  -5: 10 us,  -6: 1 us
     * -7 : 100 ns, -8 : 10 ns, -9 : 1 ns, -10: 100 ps, -11: 10 ps, -12: 1 ps
     * -13: 100 fs, -14: 10 fs, -15: 1 fs
     * @return int
     */
    int get_time_precision() const;

    PortDirection get_port_direction(int port_number) const;

    /**
     * @brief Returns number of bits for Verilog wire and reg types
     *
     * @return unsigned
     */
    unsigned get_port_width(int port_number) const;

    /**
     * @brief Get status of the simulation run
     *
     * @return Status
     */
    Status get_status();

    /**
     * @brief Get the last error message encountered
     *
     * @return const char*
     */
    const char *get_error_info();

    /**
     * @brief Causes all signals in the design to be logged to the waveform
     * database (WDB) BETA FEATURE
     *
     */
    void trace_all();

    /**
     * @brief Close simulation and free up memory used by the design
     *
     * @return XSI_INT64
     */
    uint64_t get_time();
};

template <unsigned WORDS> class Value {
  protected:
    enum Bit {
        R = 0b00,
        S = 0b10,
        X = 0b11,
        Z = 0b01,
    };

    unsigned _width;
    // constexpr static unsigned WORDS = (WIDTH + 31) / 32;
    s_xsi_vlog_logicval _value[WORDS];

  public:
    Value(unsigned width) : _width(width) {
        if ((width + 31) / 32 != WORDS) {
            throw std::runtime_error("Width does not match WORDS");
        }
    }

    p_xsi_vlog_logicval get_ptr() { return _value; }

    Bit get_bit(unsigned pos) const {
        if (pos >= _width) {
            throw std::runtime_error("Bit index out of range");
        }

        const auto &w = _value[pos / 32];
        unsigned o = pos % 32;

        uint8_t a = (w.aVal >> o) & 1;
        uint8_t b = (w.bVal >> o) & 1;

        return (Bit)((a << 1) | b);
    }

    void set_bit(unsigned pos, bool val) {
        if (pos >= _width) {
            throw std::runtime_error("Bit index out of range");
        }

        auto &w = _value[pos / 32];
        unsigned o = pos % 32;

        w.bVal &= ~(1 << o);

        if (val) {
            w.aVal |= (1 << o);
        } else {
            w.aVal &= ~(1 << o);
        }
    }

    uint64_t to_ulong() const {
        uint64_t ret = 0;
        for (unsigned i = 0; i < WORDS; i++) {
            if (_value[i].bVal == 0) {
                ret |= _value[i].aVal;
            } else {
                throw std::runtime_error("Value is not well-defined");
            }
        }
        return ret;
    }

    uint64_t set_word(unsigned widx, uint32_t val) {
        if (widx >= WORDS) {
            throw std::runtime_error("Bit index out of range");
        }

        _value[widx].aVal = val;
        _value[widx].bVal = 0;
    }

    void set_ulong(uint64_t val) {
        _value[0].aVal = val & 0xFFFFFFFF;
        _value[0].bVal = 0;
        if constexpr (WORDS > 1) {
            _value[1].aVal = (val >> 32) & 0xFFFFFFFF;
            _value[1].bVal = 0;
        }
    }

    std::string to_string() const {
        std::string ret;
        ret.reserve(_width);

        uint32_t a = 0;
        uint32_t b = 0;

        for (unsigned w = 0; w < WORDS; w++) {
            a = _value[w].aVal;
            b = _value[w].bVal;
            for (unsigned o = 0; o < 32 && (w * 32 + o < _width); o++) {
                switch (((a & 1) << 1) | (b & 1)) {
                case 0b00:
                    ret += '0';
                    break;
                case 0b10:
                    ret += '1';
                    break;
                case 0b01:
                    ret += 'Z';
                    break;
                case 0b11:
                    ret += 'X';
                    break;
                }

                a >>= 1;
                b >>= 1;
            }
        }

        return ret;
    }
};

template <PortDirection DIR, unsigned WORDS> class Port {
  protected:
    const std::shared_ptr<Kernel> _dut;
    const char *const _port_name;
    const unsigned _port_number;
    const unsigned _width;

  public:
    Port(std::shared_ptr<Kernel> dut, const char *port_name, int port_number,
         unsigned width)
        : _dut(dut), _port_name(port_name), _port_number(port_number),
          _width(width) {
        if (dut->get_port_number(port_name) != port_number) {
            throw std::runtime_error("Port number mismatch");
        }
        if (dut->get_port_direction(port_number) != DIR) {
            throw std::runtime_error("Port direction mismatch");
        }
        if (dut->get_port_width(port_number) != width) {
            throw std::runtime_error("Port width mismatch");
        }
        if ((width + 31) / 32 != WORDS) {
            throw std::runtime_error("Width does not match WORDS");
        }
    }

    PortDirection get_port_direction() const { return DIR; }
    const char *get_port_name() const { return _port_name; }
    int get_port_number() const { return _port_number; }
    int get_port_width() const { return _width; }

    void set(const Value<WORDS> &val) {
        _dut->put_value(_port_number, val.get_ptr());
    }

    Value<WORDS> get() {
        Value<WORDS> ret(_width);
        _dut->get_value(_port_number, ret.get_ptr());
        return ret;
    }

    void set_high() {
        Value<WORDS> val(_width);
        for (unsigned i = 0; i < WORDS; i++) {
            val.set_word(i, 0xFFFFFFFF);
        }
        set(val);
    }

    void set_low() {
        Value<WORDS> val(_width);
        set(val);
    }
};

} // namespace XSI
